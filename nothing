from pyrogram import Client, errors
import asyncio
import os
import json
from typing import Optional

api_id = 1234567
api_hash = "YOUR_API_HASH"
bot_token = "YOUR_BOT_TOKEN"

# replace with actual IDs (use -100... format for channels)
SOURCE = -1001234567890
DEST = -1009876543210

SESSION = "copier"
STATE_FILE = "copier_state.json"
# small pause between copies to reduce burst pressure (seconds)
INTER_COPY_SLEEP = 0.05

app = Client(SESSION, api_id=api_id, api_hash=api_hash, bot_token=bot_token)


def load_state() -> dict:
    if os.path.exists(STATE_FILE):
        with open(STATE_FILE, "r") as f:
            try:
                return json.load(f)
            except Exception:
                return {}
    return {}


def save_state(state: dict):
    with open(STATE_FILE, "w") as f:
        json.dump(state, f)


def floodwait_seconds(e: Exception) -> Optional[int]:
    # Pyrogram's FloodWait exception sometimes exposes different attributes depending on version.
    # Try common attribute names, fall back to int(parsed) from str.
    for attr in ("value", "x", "seconds", "timeout"):
        if hasattr(e, attr):
            try:
                return int(getattr(e, attr))
            except Exception:
                pass
    # fallback: try to parse digits from repr
    import re
    m = re.search(r"(\d+)", str(e))
    if m:
        return int(m.group(1))
    return None


async def message_is_video(msg) -> bool:
    # includes normal video, GIF animation, and file with video mime type
    if msg.video:
        return True
    if msg.animation:
        return True
    if msg.document and getattr(msg.document, "mime_type", "").startswith("video"):
        return True
    return False


async def main():
    state = load_state()
    last_id = state.get("last_copied_id")  # message id in source to resume from (if available)

    async with app:
        # Step 1: gather message objects (we'll iterate oldest -> newest)
        print("Gathering message list from source channel...")
        messages = []
        async for m in app.get_chat_history(SOURCE):
            # collect only messages that contain video-like media
            if await message_is_video(m):
                messages.append(m)

        print(f"Found {len(messages)} video-like messages in source channel.")

        # sort by message_id ascending (oldest first)
        messages.sort(key=lambda x: x.message_id)

        # if last_id exists, skip until message_id > last_id
        if last_id:
            print(f"Resuming after message id {last_id}")
            messages = [m for m in messages if m.message_id > last_id]

        print(f"{len(messages)} messages to copy now.")

        for idx, msg in enumerate(messages, 1):
            try:
                # copy preserves original file (no 'forwarded from' tag)
                await msg.copy(DEST)
                # small sleep so we don't blast requests
                await asyncio.sleep(INTER_COPY_SLEEP)
                # save progress
                state["last_copied_id"] = msg.message_id
                save_state(state)
                if idx % 100 == 0:
                    print(f"Copied {idx} messages so far. Last id: {msg.message_id}")
            except errors.FloodWait as e:
                wait = floodwait_seconds(e)
                wait = wait if wait is not None else 60
                print(f"[FloodWait] sleeping for {wait} seconds...")
                await asyncio.sleep(wait)
                # after waiting, retry this message once
                try:
                    await msg.copy(DEST)
                    await asyncio.sleep(INTER_COPY_SLEEP)
                    state["last_copied_id"] = msg.message_id
                    save_state(state)
                except Exception as ex2:
                    print(f"Retry failed for message {msg.message_id}: {ex2}")
            except Exception as ex:
                # log and continue (you may want to add specific handling)
                print(f"Error copying message {msg.message_id}: {repr(ex)}")
                # optional short sleep on unknown errors
                await asyncio.sleep(1)

    print("Done.")


if __name__ == "__main__":
    asyncio.run(main())